(defparameter *new-byte-columns* (copy-seq *byte-columns*))
(defparameter *new-columns* (copy-seq *columns*))
(defparameter *swapped-columns* nil)
(defparameter *replaced-columns* nil)
(defconstant +starting-unused-columns+ '(135 214))
(defparameter *unused-cols* (copy-seq +starting-unused-columns+))
(defconstant +init-column-names+
			 '((tl-tree . 99)
			   (tl-rock . 57)
			   (tl-rock2 . 214) ;tl-rock2 starts as 214, but that's a default
								;unused column
			   (tr-tree . 96)
			   (bl-tree . 64)
			   (bl-rock . 53)
			   (br-tree . 65)
			   (bl-open . 70)
			   (tl-water . 67)
			   (tr-water . 225)
			   (br-water . 224)
			   (water . 19)
			   (n-rock-water-wall . 120)
			   (l-coast . 69)
			   (high-river . 114)
			   (river-bend . 180)
			   (dock-open . 208)))

(defconstant +opposite-names+
			 '((tl-tree . tr-tree)
			   (tl-rock . tr-rock)
			   (tl-rock2 . tr-rock2)
			   (bl-tree . br-tree)
			   (bl-rock . br-rock)
			   (bl-open . br-open)
			   (tl-water . tr-water)
			   (bl-water . br-water)
			   (l-coast . r-coast)))

(defconstant +init-simplifications+
			 '((bl-open . bl-rock)
			   (br-open . br-rock)
			   (tl-rock2 . tl-rock)
			   (tr-rock2 . tr-rock)
			   (l-coast . water)
			   (r-coast . water)
			   (bl-water . water)
			   (br-water . water)
			   (tl-rock . 71)
			   (tr-rock . 71)
			   (bl-rock . 54)
			   (br-rock . 54)
			   (tl-tree . 97)
			   (tr-tree . 97)
			   (bl-tree . 72)
			   (br-tree . 72)
			   (high-river . 115)
			   (135 . 104)
			   (n-rock-water-wall . 0)
			   (n-tree-water-wall . 0)
			   (s-rock-water-wall . 0)
			   (s-tree-water-wall . 0)
			   (dock-open . dock-wall)
			   (dock-wall . dock-open)))


(defun copy-dotted-alist (alist)
  (mapcar (lambda (x) `(,(car x) . ,(cdr x))) alist))

(defparameter *simplifications* (copy-dotted-alist +init-simplifications+))

(defun simplify-column (col)
  (let ((col-name-val (assoc col *column-names*)))
	(if (and col-name-val (not (cdr col-name-val)))
	  (simplify-column (cdr (assoc col *simplifications*)))
	  col)))

(defun change-all-screen-columns (screens column-change-fun)
  (mapc (lambda (coord)
		  (unless (numberp (aref screens (car coord) (cadr coord)))
		  (setf (aref screens (car coord) (cadr coord))
				(coerce
				  (mapcar column-change-fun
						  (coerce 
							(aref screens (car coord) (cadr coord)) 'list))
				  'array))))
		(get-coords-list 16 8)))

(defun simplify-screens (screens)
  (change-all-screen-columns screens #'simplify-column))


(defconstant +tree-simplifications+
			 '((bl-open bl-rock . bl-tree)
			   (br-open br-rock . br-tree)))

(defun simplify-column-trees (column tree)
  (let ((col-name-val (assoc column *column-names*))
		(tree-simp (cdr (assoc column +tree-simplifications+))))
	(if (and col-name-val (not (cdr col-name-val)))
	  (simplify-column (if tree-simp 
						 (if tree (cdr tree-simp) (car tree-simp))
						 column))
	  column)))

(defun simplify-screens-trees (screens trees)
  (mapc (lambda (coord)
		  (unless (numberp (aref screens (car coord) (cadr coord)))
		  (setf (aref screens (car coord) (cadr coord))
				(coerce
				  (mapcar (lambda (x)
							(simplify-column-trees x (aref trees (car coord)
														   (cadr coord))))
						  (coerce 
							(aref screens (car coord) (cadr coord)) 'list))
				  'array))))
		(get-coords-list 16 8)))

(defun set-simplification (name simp)
  (if (assoc name *simplifications*)
	(setf (cdr (assoc name *simplifications*)) simp)
	(push `(,name . ,simp) *simplifications*)))

(defun finalize-simplifications ()
  (set-simplification 'bl-open 82)
  (set-simplification 'br-open 82)
  (if (cdr (assoc 'tl-rock2 *column-names*))
	(set-simplification 'tl-rock 'tl-rock2)
	(if (cdr (assoc 'tl-rock *column-names*))
	  (set-simplification 'tl-rock2 'tl-rock)
	  (progn (set-simplification 'tl-rock 81)
			 (set-simplification 'tl-rock2 71))))
  (if (cdr (assoc 'tr-rock2 *column-names*))
	(set-simplification 'tr-rock 'tr-rock2)
	(if (cdr (assoc 'tr-rock *column-names*))
	  (set-simplification 'tr-rock2 'tr-rock)
	  (progn (set-simplification 'tr-rock 81)
			 (set-simplification 'tr-rock2 71)))))

(defun filter-col-to-col-num (col)
  (let* ((simplified (simplify-column col))
		 (num-sub (cdr (assoc simplified *column-names*))))
	(if num-sub num-sub col)))

(defun filter-screens-to-col-num (screens)
  (change-all-screen-columns screens #'filter-col-to-col-num))

(defparameter *column-names*
  '((tl-tree . 99)
	(tl-rock . 57)
	(tl-rock2 . 214)
	(tr-rock2 . nil)
    (tr-tree . 96)
    (tr-rock . nil)
    (bl-tree . 64)
    (bl-rock . 53)
    (br-tree . 65)
    (br-rock . nil)
    (bl-open . 70)
	(br-open . nil)
	(tl-water . 67)
	(tr-water . 225)
	(bl-water . nil)
	(br-water . 224)
	(water . 19)
	(n-rock-water-wall . 120)
	(n-tree-water-wall . nil)
	(s-rock-water-wall . nil)
	(s-tree-water-wall . nil)
	(l-coast . 69)
	(r-coast . nil)
	(river-bend . 180)
	(ladder-river . nil)
	(high-river . 114)
	(ladder-open . nil)
	(135 . nil)
	(dock-open . 208)
	(dock-wall . nil)))

(defparameter *extra-water-corner* 152)

(defun init-column-alterer ()
  (setf *new-byte-columns* (copy-seq *byte-columns*))
  (setf *new-columns* (copy-seq *columns*))
  (setf *swapped-columns* nil)
  (setf *replaced-columns* nil)
  (setf *unused-cols* (copy-seq +starting-unused-columns+))
  (mapc (lambda (x) (let ((col-val (cdr (assoc (car x) +init-column-names+))))
					  (if col-val 
						(setf (cdr x) col-val)
						(setf (cdr x) nil))))
		*column-names*)
  (setf *simplifications* (copy-dotted-alist +init-simplifications+)))

(defun set-column-name (col-name col-num)
  (let ((col-set (assoc col-name *column-names*)))
	(when col-set
	  (setf (cdr col-set) col-num))))

(defun remove-column-name (col-num)
  (let ((col-set (rassoc col-num *column-names*)))
	(when col-set
	  (setf (cdr col-set) nil))))

(defun change-byte-to-tile (byt)
  (let ((tile (mod byt #x40))) (if (zerop (floor (mod byt #x80) #x40))
								 `(,tile)
							     `(,tile ,tile))))

(defun change-bytes-to-column (bytes)
  (apply #'append (mapcar #'change-byte-to-tile bytes)))

(defun seek-to-byte-column (col-num)
  (loop for x from 0 to (1- (length *new-byte-columns*))
		with countdown = (1+ (convert-column-number col-num))
		when (> (aref *new-byte-columns* x) #x7F) do (decf countdown)
		when (zerop countdown) return x))

(defun seek-byte-column-from (col-offset start-index)
  (loop for x from (1+ start-index) to (1- (length *new-byte-columns*))
		with countdown = col-offset
		when (> (aref *new-byte-columns* x) #x7F) do (decf countdown)
		when (zerop countdown) return x))

(defun replace-bytes (start-index new-bytes)
  (mapcar (lambda (i new) (setf (aref *new-byte-columns* i) new))
		  (interval start-index (+ start-index (1- (length new-bytes))))
		  new-bytes))

(defun get-byte-column (start-index)
  (labels ((get-one-r (i acc)
					  (if (> (length acc) 10)
						acc
						(get-one-r (1+ i) 
								   (append acc 
										   (change-byte-to-tile 
											 (aref *new-byte-columns* i)))))))
	(get-one-r start-index nil)))

(defun column-predecessor (col-num)
  (when (> col-num 0) 
	(rev-convert-col-num (1- (convert-column-number col-num)))))
 
(defun column-successor (col-num)
  (when (< col-num 249)
	(rev-convert-col-num (1+ (convert-column-number col-num)))))

(defun get-pred-col-succ (col-num)
  (let* ((pred-index (if (column-predecessor col-num) 
					   (seek-to-byte-column (column-predecessor col-num))
					   nil))
		 (col-index (if pred-index (seek-byte-column-from 1 pred-index) 0))
		 (succ-index (if (column-successor col-num)
					   (seek-byte-column-from 1 col-index)
					   nil)))
	(values pred-index col-index succ-index)))

(define-condition missing-simplification-needed-error (error)
  ((column :initarg :column :reader column)))

(defun new-column-by-number (num)
  (if (numberp num)
	(aref *new-columns* (convert-column-number num))
	(let ((sub (cdr (assoc num *column-names*)))
		  (simp (cdr (assoc num *simplifications*))))
	  (if sub 
		(new-column-by-number sub)
		(if simp
		  (new-column-by-number simp)
		  (error 'missing-simplification-needed-error :column num))))))

 
(defun change-column (col-num changed-bytes)
  (replace-bytes (seek-to-byte-column col-num) changed-bytes)
  (multiple-value-bind (pred-index start-index succ-index)
	(get-pred-col-succ col-num)
	(setf (aref *new-columns* (convert-column-number col-num))
		  (get-byte-column start-index))
	(when pred-index
	  (setf (aref *new-columns* (1- (convert-column-number col-num)))
			(get-byte-column pred-index)))
	(when succ-index
	  (setf (aref *new-columns* (1+ (convert-column-number col-num)))
			(get-byte-column succ-index)))))


(defun use-unused-column (changed-bytes name)
  (flet ((byte-col-length (col-num)
					(multiple-value-bind (pred-index start-index succ-index)
					  (get-pred-col-succ col-num)
					  (- succ-index start-index))))
	(let ((best-unused
			(cdr
			  (reduce (lambda (x y) (if (< (car y) (car x)) y x))
				(remove-if (lambda (x) (< (car x) 0))
						   (mapcar (lambda (x) 
									 `(,(- (byte-col-length x) 
										   (length changed-bytes)) . ,x))
								   *unused-cols*))))))
	  (if best-unused
		(progn (setf *unused-cols* (remove best-unused *unused-cols*))
			   (change-column best-unused changed-bytes)
			   (remove-column-name best-unused)
			   (set-column-name name best-unused)
			   t)
		nil))))
						  

;Finds if bridge goes west from shore or east from shore. Changes
;column 68 to appropriate facing if necessary, flipping 225 and 67
;to do so due to tile conflicts.
(defun set-bridge-dir (overworld-map horizontals verticals)
  (if (some (lambda (coord)
			  (and (member 'island (aref overworld-map (car coord) 
										 (cadr coord)))
				   (eq (east-edge horizontals verticals (car coord) 
								  (cadr coord)) 'bridge)))
			(get-coords-list (array-dimension overworld-map 1)
							 (array-dimension overworld-map 0)))
	'west
	(progn (change-column 68 '(#xc8 #x48 #x08 #x0b #x48 #x48 #x08)) 
		   (change-column 225 '(#xc5 #x45 #x45 #x09 #x49 #x49))
		   (set-column-name 'tl-water 225)
		   (set-column-name 'tr-water 67)
		   (push '(67 225) *swapped-columns*)
		   'east)))

(defun set-flat-coast (overworld-map horizontals bridge-dir)
  (let* ((biome-ids (cdr (assoc 'coast-cluster *special-biome-identifiers*)))
		 (loc (car biome-ids))
		 (vert (caddr biome-ids))
		 (horiz (cadddr biome-ids)))
	(if (or (member loc '(top-right bottom-right))
			(and (not (member loc '(top-left bottom-left)))
				 (or (and (eq loc 'top) 
						  (member 'coast (aref overworld-map (funcall vert 2)
											   (funcall horiz 0))))
					 (eq bridge-dir 'west))))
	  'east
	  (progn (change-column 69 '(#xc9 #x49 #x09 #x49 #xc9 #x49 #x18))
			 (set-column-name 'r-coast 69)
			 (set-column-name 'l-coast nil)
			 (set-column-name 'br-open 70)
			 (set-column-name 'bl-open nil)
			 'west))))

;This function ensures that we always have the rock-water-wall necessary
;to cap off the coast.
;Currently always removes column 150. At some point, I'd like to make
;it technically possible to generate the original overworld, which
;means this will have to be changed.
(defun alter-coast-end (overworld-map)
  (let* ((coast-edge (cadr (assoc 'coast-edge *biome-coords-list*)))
		(vert-end-point 
		  (find-if (lambda (x) (member 
								 (cadr x) 
								 `(0 ,(1- (array-dimension overworld-map 1))))) 
				   (list (first coast-edge) (car (last coast-edge))))))
	(if (and (eq (cadr (assoc 'coast-cluster *special-biome-identifiers*))
				 'bottom)
			 (not (cdr (assoc 'n-rock-water-wall *column-names*))))
	  (progn (push 150 *unused-cols*)
			 (use-unused-column '(#xdb #x5b #x5b #x45 #x45 #x05)
								'n-rock-water-wall))
	  (if vert-end-point
		(cond ((member 'coast (get-screen-biome overworld-map 
												(1- (car vert-end-point))
												(cadr vert-end-point)))
			   (push 150 *unused-cols*)
			   (unless (cdr (assoc 's-rock-water-wall *column-names*))
				 (use-unused-column '(#xc5 #x45 #x05 #x5b #x5b #x5b)
									's-rock-water-wall)))
			  ((member 'coast (get-screen-biome overworld-map
												(1+ (car vert-end-point))
												(cadr vert-end-point)))
			   (push 150 *unused-cols*)
			   (unless (cdr (assoc 'n-rock-water-wall *column-names*))
				 (use-unused-column '(#xdb #x5b #x5b #x45 #x45 #x05)
									'n-rock-water-wall)))
			  (t (push 150 *unused-cols*)))))))


(defun find-water-corners (overworld-map)
  (let ((big-lake-origin (cadr (assoc 'big-lake *special-biome-identifiers*)))
		(big-lake-rotation (caddr (assoc 'big-lake 
										 *special-biome-identifiers*)))
		
		(top-left nil)
		(top-right nil)
		(bottom-left nil)
		(bottom-right nil)
		(small-lake-origin (cadr (assoc 'small-lake 
										*special-biome-identifiers*)))
		(coast-loc (cadr (assoc 'coast-cluster *special-biome-identifiers*)))
		(coast-dir (caddr (assoc 'coast-cluster *special-biome-identifiers*))))
	(flet ((add-if-needed (coord corner-type)
						  (if (intersection (aref overworld-map (car coord)
												  (cadr coord))
											'(forest woods))
							(unless (member 'tree corner-type)
							  (push 'tree corner-type))
							(unless (member 'rock corner-type)
							  (push 'rock corner-type))))
		   (coast-add (corner-list)
					  (mapc (lambda (x) (unless (member 'rock x)
										  (push 'rock x)))
							corner-list))
		   (shift (coord y x)
						(list (+ y (car coord)) (+ x (cadr coord)))))
	  (add-if-needed small-lake-origin top-left)
	  (add-if-needed (shift small-lake-origin 0 1) top-right)
	  (add-if-needed (shift small-lake-origin 1 0) bottom-left)
	  (add-if-needed (shift small-lake-origin 1 1) bottom-right)
	  (let ((big-lake-corner-offsets 
			  (nth big-lake-rotation
				   `(((,top-left (0 2) (1 0)) (,top-right (0 4))
					  (,bottom-left (3 0)) (,bottom-right (2 4) (3 2)))
					 ((,top-left (0 0)) (,top-right (0 2) (1 4))
					  (,bottom-left (2 0) (3 2)) (,bottom-right (3 4)))
					 ((,top-left (0 1) (2 0)) (,top-right (0 3))
					  (,bottom-left (4 0)) (,bottom-right (2 3) (4 2)))
					 ((,top-left (0 0)) (,top-right (0 2) (2 3))
					  (,bottom-left (2 0) (4 1)) (,bottom-right (4 3)))))))
		(mapc (lambda (loc)
				(mapc (lambda (delta)
						(add-if-needed (shift big-lake-origin 
											  (car delta) (cadr delta))
									   (car loc)))
					  (cdr loc)))
			  big-lake-corner-offsets))
	  (cond ((eq coast-loc 'top-right)
			 (if (eq coast-dir 'horizontal)
			   (coast-add (list bottom-left bottom-right))
			   (coast-add (list bottom-left top-left))))
			((eq coast-loc 'top-left)
			 (if (eq coast-dir 'horizontal)
			   (coast-add (list bottom-left bottom-right))
			   (coast-add (list bottom-right top-right))))
			((eq coast-loc 'bottom-right)
			 (if (eq coast-dir 'horizontal)
			   (coast-add (list bottom-right))
			   (coast-add (list bottom-left top-left))))
			((eq coast-loc 'bottom-left)
			 (if (eq coast-dir 'horizontal)
			   (coast-add (list bottom-left))
			   (coast-add (list bottom-right top-right))))
			(t
			  (let* ((coast-id 
					   (cdr (assoc 'coast-cluster *special-biome-identifiers*)))
					 (vert (caddr coast-id))
					 (horiz (cadddr coast-id)))
				(if (eq coast-loc 'top)
				  (coast-add (list bottom-left bottom-right))
				  (coast-add (list
							   (if (member 'coast (aref overworld-map 
														(funcall vert 2)
														(funcall horiz 0)))
								 bottom-right
								 bottom-left))))))))
	(values top-left top-right bottom-left bottom-right)))

(defun change-water-corners (overworld-map coast-side)
  (multiple-value-bind (top-left top-right bottom-left bottom-right)
	(find-water-corners overworld-map)
	(unless (member 'rock bottom-left)
	  (push 53 *unused-cols*))
	(unless (member 'tree top-right)
	  (push 96 *unused-cols*))
	(when (member 'rock top-right)
	  (if (member 'rock top-left)
		(use-unused-column '(#xdb #x4e #x4e #x16 #x49 #x49) 'tr-rock)
		(progn (change-column 57 '(#xdb #x4e #x4e #x16 #xc9 #x49 #x18))
			   (change-column 65 '(#xc8 #x48 #x17))
			   (set-column-name 'tl-rock nil)
			   (set-column-name 'tr-rock 57)
			   (set-column-name 'bl-tree 65)
			   (set-column-name 'br-tree 64)
			   (push '(64 65) *swapped-columns*))))
	(when (member 'rock bottom-right)
	  (if (eq coast-side 'west)
		(progn (change-column 70 '(#xc9 #x49 #x18 #x4e #x4e #x5b))
			   (remove-column-name 70)
			   (set-column-name 'br-rock 70)
			   (push '(70 53) *replaced-columns*))
		(if (member 'rock bottom-left)
		  (progn (change-column 70 '(#xc8 #x48 #x17 #x4e #x4e #x5b))
				 (change-column 53 '(#xc9 #x49 #x18 #x4e #x4e #x1a #x1b))
				 (push '(53 70) *replaced-columns*))
		  (unless
			(use-unused-column '(#xc9 #x49 #x18 #x4e #x4e #x1a #x1b)
							   'br-rock)
			(use-unused-column '(#xc9 #x49 #x18 #x4e #x5b)
							   'br-rock)))))))

(defun change-water-x-wall (overworld-map horizontals verticals lake-wall)
  (princ lake-wall)
  (when (and lake-wall (eql (caar lake-wall) (caadr lake-wall)))
	(if (member (north-edge horizontals verticals 
							(caar lake-wall) (cadar lake-wall))
			'(water-wall dock))
	  (progn (change-column 120 '(#xc5 #x45 #x45 #x45))
			 (set-column-name 'water 120)
			 (set-column-name 'n-rock-water-wall nil)
			 (let ((union-biome (union (aref overworld-map (caar lake-wall)
											 (cadar lake-wall))
									   (aref overworld-map (caadr lake-wall)
											 (cadadr lake-wall)))))
			   (if (intersection '(mountain hills) union-biome)
				 (progn (change-column 19 '(#xc5 #x45 #x05 #x5b #x5b #x5b))
						(set-column-name 's-rock-water-wall 19))
				 (progn (change-column 19 '(#xc5 #x45 #x05 #x59 #x59 #x59))
						(set-column-name 's-tree-water-wall 19)))
			   (when (and (intersection '(mountain hills) union-biome)
						  (intersection '(forest woods) union-biome))
				 (use-unused-column '(#xc5 #x45 #x05 #x59 #x59 #x59)
									's-tree-water-wall))))
	  (progn (let ((union-biome (union (aref overworld-map (caar lake-wall)
											 (cadar lake-wall))
									   (aref overworld-map (caadr lake-wall)
											 (cadadr lake-wall)))))
			   (when (intersection '(forest woods) union-biome)
				 (if (intersection '(mountain hills) union-biome)
				   (use-unused-column '(#xd9 #x59 #x59 #x45 #x45 #x05)
									  'n-tree-water-wall)
				   (progn (change-column 120 '(#xd9 #x59 #x59))
						  (set-column-name 'n-tree-water-wall 120)
						  (set-column-name 'n-rock-water-wall nil)))))))))
			   

(defun change-lower-corner (coast-loc)
  (unless (or (use-unused-column '(#xc9 #x49 #x09 #x45 #x45 #x45) 
								 'bl-water)
			  (member coast-loc '(top-right bottom-right top bottom)))
	(change-column 224 '(#xc9 #x49 #x09 #xc5 #x45 #x45))
	(set-column-name 'bl-water 224)
	(set-column-name 'br-water nil)
	(push '(224 19) *replaced-columns*)))

(defun change-river-columns (overworld-map horizontals verticals)
  (let* ((river-mouth (find-if (lambda (x) 
								(every (lambda (y) 
										 (member y (aref overworld-map (car x) 
														 (cadr x))))
									   '(big-lake river-in)))
							  (get-coords-list 
								(array-dimension overworld-map 1)
								(array-dimension overworld-map 0))))
		(main-river (remove-if (lambda (x)
								 (or (not (member 'river-in
												  (aref overworld-map (car x)
														(cadr x))))
									 (member 'big-lake
											 (aref overworld-map (car x)
												   (cadr x)))))
							  (get-coords-list 
								(array-dimension overworld-map 1)
								(array-dimension overworld-map 0))))
		(river-biome (if (intersection '(mountain hills)
									   (aref overworld-map (caar main-river)
											 (cadar main-river)))
					   'rock 'tree))
		(river-dir (if (find-if (lambda (x) (> (cadr x) (cadr river-mouth)))
								main-river) 'right 'left)))
	(cond ((< (car river-mouth) (caar main-river))
		   (change-column 152 (append '(#xc5 #x45) 
									  (if (eq river-dir 'right) '(#x17) '(#x18))
									  '(#x4e)
									  (if (eq river-biome 'rock)
										(if (eq river-dir 'right)
										  '(#x0e #x33)
										  '(#x0e #x32))
										'(#x4e #x59))))
		   (set-column-name 'river-bend 152)
		   (setf *extra-water-corner* 180))
		  ((eql (car river-mouth) (caar main-river))
		   (change-column 180 (append '(#xdb #x5b #x07)
									  (if (eq river-dir 'right)
										(if (eq 'bridge (west-edge 
														  horizontals verticals
														  (car river-mouth)
														  (cadr river-mouth)))
										  '(#x0e #x4e #x33)
										  '(#x2e #x4e #x33))
										(if (eq 'bridge (east-edge 
														  horizontals verticals
														  (car river-mouth)
														  (cadr river-mouth)))
										  '(#x0e #x4e #x32)
										  '(#x2f #x4e #x32))))))
		  ((eq river-dir 'left)
		   (change-column 180 '(#xdb #x5b #x16 #x45 #x45 #x45))))
	(when (intersection '(forest woods) (aref overworld-map (caar main-river)
											  (cadar main-river)))
	  (change-column 176 '(#xdb #x59 #x07 #x4e #x4e #x4e))
	  ;Line below also changes column 115
	  (change-column 114 '(#xd9 #x59 #x07 #x4e #x19 #x19 
						   #xd9 #x59 #x07 #x4e #x4e #x19 #x19))
	  (change-column 212 '(#xd9 #x19 #x28 #x07 #x4e #x19 #x59 #x19)))
	(when (some (lambda (x) (and (eq (north-edge horizontals verticals 
											(car x) (cadr x))
									 'edge)
								 (not (intersection '(river-in spring)
											  (aref overworld-map (1- (car x))
													(cadr x))))))
				(cons river-mouth main-river))
	  (change-column 114 `(#xce #x4e #x07 #x4e))
	  (set-column-name 'high-river nil)
	  (set-column-name 'ladder-river 114))))

(defun clear-unused-columns ()
  (when *unused-cols*
	(if (cdr (assoc 'l-coast *column-names*))
	  (use-unused-column '(#xc9 #x49 #x09 #x49 #x49 #x49) 'r-coast)
	  (use-unused-column '(#xc8 #x48 #x08 #x48 #x48 #x48) 'l-coast)))
  (when *unused-cols*
	(use-unused-column '(#xca #x4e #x4e #x0e #x4e #x4e) 'ladder-open))
  (when (and *unused-cols* (eq (caddr (assoc 'coast-cluster 
											 *special-biome-identifiers*))
							   'vertical))
	(if (member (cadr (assoc 'coast-cluster *special-biome-identifiers*))
				'(top-right bottom-right))
	  (use-unused-column '(#xdb #x5b #x1b #x0e #x15 #x48 #x48) 'tl-rock2)
	  (use-unused-column '(#xdb #x5b #x1b #x0e #x16 #x49 #x49) 'tr-rock2))))

(defun change-dock (overworld-map horizontals verticals)
  (let ((dock-coords (remove-if (lambda (x) (not (eq (aref verticals (car x)
														   (cadr x))
													 'dock)))
								(get-coords-list 16 7))))
	(when (some (lambda (x) (intersection (aref overworld-map (+ 2 (car x))
												(cadr x))
										  '(spring open-ruin a-fairy
												island pond))) dock-coords)
	  (unless (use-unused-column (append '(#xc5 #x45 #x0B #x4e #x4e)
										 (if (intersection
											   '(forest woods)
											   (aref overworld-map (1+ (car x))
													 (cadr x)))
										   '(#x59) '(#x1a #x1b)))
								 'dock-wall)
		(change-column 208 (append '(#xc5 #x45 #x0B #x4e #x4e)
								   (if (intersection '(forest-woods)
													 (aref overworld-map
														   (1+ (car x))
														   (cadr x)))
									 '(#x59) '(#x1a))))
		(remove-column-name 208)
		(set-column-name 'dock-wall 208)))))

(defun alter-columns (overworld-map horizontals verticals)
  (init-column-alterer)
  (change-water-x-wall overworld-map horizontals verticals *lake-wall*)
  (alter-coast-end overworld-map)
  (change-river-columns overworld-map horizontals verticals)
  (change-water-corners overworld-map
				(set-flat-coast overworld-map horizontals 
								(set-bridge-dir overworld-map horizontals 
												verticals)))
  (change-lower-corner (cadr (assoc 'coast-cluster 
									*special-biome-identifiers*)))
  (change-dock overworld-map horizontals verticals)
  (clear-unused-columns)
  (unless (assoc 'tr-rock *column-names*)
	(setf (cdr (assoc 'tr-rock2 *simplifications*)) 81)))


					;note: use column 152 for south-side rivers
